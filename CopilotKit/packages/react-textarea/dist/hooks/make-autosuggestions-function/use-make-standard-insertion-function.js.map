{"version":3,"sources":["../../../src/hooks/make-autosuggestions-function/use-make-standard-insertion-function.tsx","../../../src/lib/retry.tsx"],"sourcesContent":["import { COPILOT_CLOUD_PUBLIC_API_KEY_HEADER } from \"@copilotkit/shared\";\nimport { useCopilotContext } from \"@copilotkit/react-core\";\nimport { useCallback } from \"react\";\nimport {\n  CopilotRuntimeClient,\n  Message,\n  Role,\n  TextMessage,\n  convertGqlOutputToMessages,\n  convertMessagesToGqlInput,\n  filterAgentStateMessages,\n  CopilotRequestType,\n} from \"@copilotkit/runtime-client-gql\";\nimport { retry } from \"../../lib/retry\";\nimport {\n  EditingEditorState,\n  Generator_InsertionOrEditingSuggestion,\n} from \"../../types/base/autosuggestions-bare-function\";\nimport { InsertionsApiConfig } from \"../../types/autosuggestions-config/insertions-api-config\";\nimport { EditingApiConfig } from \"../../types/autosuggestions-config/editing-api-config\";\nimport { DocumentPointer } from \"@copilotkit/react-core\";\n\n/**\n * Returns a memoized function that sends a request to the specified API endpoint to get an autosuggestion for the user's input.\n * The function takes in the text before and after the cursor, and an abort signal.\n * It sends a POST request to the API endpoint with the messages array containing the system message, few shot messages, and user messages.\n * The function returns the suggestion from the API response.\n *\n * @param textareaPurpose - The purpose of the textarea. This is included in the system message.\n * @param apiEndpoint - The API endpoint to send the autosuggestion request to.\n * @param makeSystemMessage - A function that takes in a context string and returns a system message to include in the autosuggestion request.\n * @param fewShotMessages - An array of few shot messages to include in the autosuggestion request.\n * @param contextCategories - The categories of context strings we want to include. By default, we include the (default) \"global\" context category.\n * @returns A memoized function that sends a request to the specified API endpoint to get an autosuggestion for the user's input.\n */\nexport function useMakeStandardInsertionOrEditingFunction(\n  textareaPurpose: string,\n  contextCategories: string[],\n  insertionApiConfig: InsertionsApiConfig,\n  editingApiConfig: EditingApiConfig,\n): Generator_InsertionOrEditingSuggestion {\n  const { getContextString, copilotApiConfig } = useCopilotContext();\n  const headers = {\n    ...(copilotApiConfig.publicApiKey\n      ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: copilotApiConfig.publicApiKey }\n      : {}),\n  };\n\n  const runtimeClient = new CopilotRuntimeClient({\n    url: copilotApiConfig.chatApiEndpoint,\n    publicApiKey: copilotApiConfig.publicApiKey,\n    headers,\n    credentials: copilotApiConfig.credentials,\n  });\n\n  async function runtimeClientResponseToStringStream(\n    responsePromise: ReturnType<typeof runtimeClient.generateCopilotResponse>,\n  ) {\n    const messagesStream = await CopilotRuntimeClient.asStream(responsePromise);\n\n    return new ReadableStream({\n      async start(controller) {\n        const reader = messagesStream.getReader();\n        let sentContent = \"\";\n\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {\n            break;\n          }\n\n          const messages = convertGqlOutputToMessages(value.generateCopilotResponse.messages);\n\n          let newContent = \"\";\n\n          for (const message of messages) {\n            if (message.isTextMessage()) {\n              newContent += message.content;\n            }\n          }\n          if (newContent) {\n            const contentToSend = newContent.slice(sentContent.length);\n            controller.enqueue(contentToSend);\n            sentContent += contentToSend;\n          }\n        }\n        controller.close();\n      },\n    });\n  }\n\n  const insertionFunction = useCallback(\n    async (\n      editorState: EditingEditorState,\n      insertionPrompt: string,\n      documents: DocumentPointer[],\n      abortSignal: AbortSignal,\n    ) => {\n      const res = await retry(async () => {\n        const messages: Message[] = [\n          new TextMessage({\n            role: Role.System,\n            content: insertionApiConfig.makeSystemPrompt(\n              textareaPurpose,\n              getContextString(documents, contextCategories),\n            ),\n          }),\n          ...insertionApiConfig.fewShotMessages,\n          new TextMessage({\n            role: Role.User,\n            content: `<TextAfterCursor>${editorState.textAfterCursor}</TextAfterCursor>`,\n          }),\n          new TextMessage({\n            role: Role.User,\n            content: `<TextBeforeCursor>${editorState.textBeforeCursor}</TextBeforeCursor>`,\n          }),\n          new TextMessage({\n            role: Role.User,\n            content: `<InsertionPrompt>${insertionPrompt}</InsertionPrompt>`,\n          }),\n        ];\n\n        return runtimeClientResponseToStringStream(\n          runtimeClient.generateCopilotResponse({\n            data: {\n              frontend: {\n                actions: [],\n                url: window.location.href,\n              },\n              messages: convertMessagesToGqlInput(filterAgentStateMessages(messages)),\n              metadata: {\n                requestType: CopilotRequestType.TextareaCompletion,\n              },\n            },\n            properties: copilotApiConfig.properties,\n            signal: abortSignal,\n          }),\n        );\n      });\n\n      return res;\n    },\n    [insertionApiConfig, getContextString, contextCategories, textareaPurpose],\n  );\n\n  const editingFunction = useCallback(\n    async (\n      editorState: EditingEditorState,\n      editingPrompt: string,\n      documents: DocumentPointer[],\n      abortSignal: AbortSignal,\n    ) => {\n      const res = await retry(async () => {\n        const messages: Message[] = [\n          new TextMessage({\n            role: Role.System,\n            content: editingApiConfig.makeSystemPrompt(\n              textareaPurpose,\n              getContextString(documents, contextCategories),\n            ),\n          }),\n          ...editingApiConfig.fewShotMessages,\n          new TextMessage({\n            role: Role.User,\n            content: `<TextBeforeCursor>${editorState.textBeforeCursor}</TextBeforeCursor>`,\n          }),\n          new TextMessage({\n            role: Role.User,\n            content: `<TextToEdit>${editorState.selectedText}</TextToEdit>`,\n          }),\n          new TextMessage({\n            role: Role.User,\n            content: `<TextAfterCursor>${editorState.textAfterCursor}</TextAfterCursor>`,\n          }),\n          new TextMessage({\n            role: Role.User,\n            content: `<EditingPrompt>${editingPrompt}</EditingPrompt>`,\n          }),\n        ];\n\n        const runtimeClient = new CopilotRuntimeClient({\n          url: copilotApiConfig.chatApiEndpoint,\n          publicApiKey: copilotApiConfig.publicApiKey,\n          headers,\n          credentials: copilotApiConfig.credentials,\n        });\n\n        return runtimeClientResponseToStringStream(\n          runtimeClient.generateCopilotResponse({\n            data: {\n              frontend: {\n                actions: [],\n                url: window.location.href,\n              },\n              messages: convertMessagesToGqlInput(filterAgentStateMessages(messages)),\n              metadata: {\n                requestType: CopilotRequestType.TextareaCompletion,\n              },\n            },\n            properties: copilotApiConfig.properties,\n            signal: abortSignal,\n          }),\n        );\n      });\n\n      return res;\n    },\n    [editingApiConfig, getContextString, contextCategories, textareaPurpose],\n  );\n\n  const insertionOrEditingFunction = useCallback(\n    async (\n      editorState: EditingEditorState,\n      insertionPrompt: string,\n      documents: DocumentPointer[],\n      abortSignal: AbortSignal,\n    ) => {\n      if (editorState.selectedText === \"\") {\n        return await insertionFunction(editorState, insertionPrompt, documents, abortSignal);\n      } else {\n        return await editingFunction(editorState, insertionPrompt, documents, abortSignal);\n      }\n    },\n    [insertionFunction, editingFunction],\n  );\n\n  return insertionOrEditingFunction;\n}\n","export function retry<T>(\n  fn: () => Promise<T>,\n  retriesLeft: number = 2,\n  interval: number = 200,\n  backoff: number = 1.5,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    fn()\n      .then(resolve)\n      .catch((error) => {\n        if (retriesLeft === 1) {\n          reject(error);\n          return;\n        }\n\n        setTimeout(() => {\n          retry(fn, retriesLeft - 1, interval * backoff, backoff)\n            .then(resolve)\n            .catch(reject);\n        }, interval);\n      });\n  });\n}\n"],"mappings":"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","names":["runtimeClient"]}